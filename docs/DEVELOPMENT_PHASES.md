# Development Phases

## 개발 일정 및 마일스톤

Bottom-up 방식으로 단계별 구현을 진행합니다. 각 단계는 독립적으로 테스트 가능하며, 다음 단계의 기반이 됩니다.

## Phase 1: 기초 데이터 구조

### 목표
제네시스 블록을 생성하고 블록 해시를 계산할 수 있는 기본 구조 완성

### 구현 항목

#### 1.1 프로젝트 설정
- Cargo 프로젝트 초기화
- 필수 의존성 추가
- 모듈 구조 설계
- 기본 테스트 환경 구축

#### 1.2 기본 타입 정의
- Transaction
  - TxInput: previous_output (txid, vout), script_sig
  - TxOutput: value, script_pubkey
  - version, lock_time
- Block
  - BlockHeader: version, prev_block_hash, merkle_root, timestamp, bits, nonce
  - transactions
- Hash256 wrapper 타입

#### 1.3 직렬화
- Serialize/Deserialize trait 구현
- 네트워크 바이트 순서 처리
- VarInt 인코딩/디코딩
- 트랜잭션 및 블록 직렬화

#### 1.4 해싱
- SHA256 double hash 함수
- 트랜잭션 ID 계산
- 블록 해시 계산
- Merkle root 계산

#### 1.5 제네시스 블록
- 고정된 제네시스 블록 정의
- Coinbase 트랜잭션 생성
- 제네시스 블록 검증

### 완료 기준
- 제네시스 블록 생성 및 해시 계산
- 블록/트랜잭션 직렬화 테스트 통과
- 유닛 테스트 작성 완료

### 예상 산출물
- 작동하는 기본 데이터 구조
- 제네시스 블록을 생성하는 예제
- 단위 테스트 스위트

---

## Phase 2: 검증 로직

### 목표
수동으로 생성한 블록과 트랜잭션을 검증할 수 있는 시스템 구축

### 구현 항목

#### 2.1 Proof of Work
- 난이도 타겟 계산 (고정 난이도)
- 블록 해시 검증 (해시 < 타겟)
- 채굴 함수 (nonce 탐색 루프)
- PoW 단위 테스트

#### 2.2 암호화 통합
- secp256k1 크레이트 통합
- 키페어 생성
- ECDSA 서명 생성
- ECDSA 서명 검증
- 공개키 해싱 (SHA256 + RIPEMD160)

#### 2.3 Bitcoin Script (P2PKH)
- Script 데이터 구조
- P2PKH scriptPubKey 생성
- P2PKH scriptSig 생성
- 스크립트 인터프리터 (간소화)
  - OP_DUP
  - OP_HASH160
  - OP_EQUALVERIFY
  - OP_CHECKSIG
- 스크립트 실행 및 검증

#### 2.4 트랜잭션 검증
- 입력 서명 검증
- 입출력 금액 밸런스 확인
- Coinbase 트랜잭션 특수 처리
- 트랜잭션 구조 유효성 검사

#### 2.5 블록 검증
- PoW 검증
- Merkle root 검증
- 블록 내 모든 트랜잭션 검증
- 타임스탬프 유효성
- 블록 크기 제한

### 완료 기준
- 유효한 블록을 검증할 수 있음
- 유효한 트랜잭션을 검증할 수 있음
- 잘못된 블록/트랜잭션을 거부함
- 통합 테스트 작성 완료

### 예상 산출물
- 완전한 검증 모듈
- 채굴 기능 (테스트용)
- P2PKH 트랜잭션 생성 및 검증
- 검증 테스트 케이스

---

## Phase 3: 블록체인 & 저장소

### 목표
여러 블록을 체인으로 연결하고 영구 저장할 수 있는 시스템 구축

### 구현 항목

#### 3.1 Chain 관리
- Blockchain 상태 관리
- 블록 추가 (longest chain rule)
- 블록 높이 추적
- 체인 재구성 (reorg)
- 포크 감지 및 처리

#### 3.2 UTXO Set
- UTXO 자료구조 설계
- UTXO 추가 (새 트랜잭션 출력)
- UTXO 제거 (트랜잭션 입력 소비)
- UTXO 존재 확인
- 잔액 계산

#### 3.3 Database 통합
- sled 데이터베이스 설정
- 블록 저장 스키마
- UTXO 저장 스키마
- 인덱싱 (블록 해시, 블록 높이)
- 트랜잭션 지원 (원자성)

#### 3.4 데이터 영속성
- 블록 저장 및 로드
- UTXO set 저장 및 로드
- 체인 상태 복원
- 데이터 무결성 검증

#### 3.5 초기 블록 다운로드 (IBD) 준비
- 블록 순차 추가
- 블록 검증 파이프라인
- 진행 상태 추적

### 완료 기준
- 여러 블록을 체인에 추가 가능
- 블록체인 상태가 재시작 후에도 유지됨
- UTXO set이 정확히 추적됨
- 이중 지불이 감지됨
- 통합 테스트 통과

### 예상 산출물
- 완전한 블록체인 관리자
- 영구 저장소 계층
- UTXO 인덱스
- 체인 상태 복원 기능

---

## Phase 4: P2P 네트워크

### 목표
여러 노드가 서로 연결되어 블록과 트랜잭션을 공유하는 P2P 네트워크 구축

### 구현 항목

#### 4.1 네트워크 프로토콜
- 프로토콜 메시지 정의
  - Version/Verack (핸드셰이크)
  - Ping/Pong (연결 유지)
  - Inv (데이터 알림)
  - GetData/Block/Tx (데이터 요청/응답)
  - GetBlocks/Blocks (블록 동기화)
- 메시지 직렬화/역직렬화
- 메시지 헤더 (magic bytes, 체크섬)

#### 4.2 Peer 연결 관리
- TCP 연결 수락 및 개시
- 핸드셰이크 수행
- 피어 메타데이터 관리
- 연결 타임아웃 및 재연결
- 최대 피어 수 제한

#### 4.3 Peer 발견
- 초기 시드 노드 설정
- 피어 주소 교환
- 피어 목록 저장 및 로드
- 자동 피어 발견

#### 4.4 블록 전파
- 새 블록 수신 및 검증
- 유효한 블록을 피어에게 릴레이
- Inv 메시지로 블록 알림
- GetData로 블록 요청
- 중복 블록 필터링

#### 4.5 트랜잭션 전파
- 새 트랜잭션 수신 및 검증
- 메모리 풀에 추가
- 유효한 트랜잭션을 피어에게 릴레이
- 중복 트랜잭션 필터링

#### 4.6 블록 동기화
- 피어 블록 높이 비교
- GetBlocks 메시지로 블록 요청
- 블록 다운로드 및 검증
- 순차적 블록 추가
- 동기화 완료 확인

#### 4.7 비동기 네트워킹
- tokio runtime 설정
- async TCP 리스너
- 비동기 메시지 핸들러
- 동시 피어 처리

### 완료 기준
- 여러 노드가 P2P 네트워크 형성
- 블록이 네트워크 전체에 전파됨
- 트랜잭션이 네트워크 전체에 전파됨
- 새 노드가 기존 체인과 동기화됨
- 네트워크 분할 후 재연결 가능

### 예상 산출물
- 완전한 P2P 네트워크 스택
- 피어 관리자
- 메시지 핸들러
- 블록/트랜잭션 릴레이 시스템
- 네트워크 테스트 (로컬 다중 노드)

---

## Phase 5: 지갑 & CLI

### 목표
사용자가 CLI를 통해 노드를 조작하고 트랜잭션을 생성할 수 있는 완전한 시스템 구축

### 구현 항목

#### 5.1 Keystore
- 개인키 생성 (secp256k1)
- 공개키 유도
- 주소 생성 (P2PKH, Base58Check)
- 키 저장 (암호화 선택적)
- 키 로드 및 복원
- 여러 주소 관리

#### 5.2 Transaction Builder
- UTXO 선택 알고리즘 (간단한 전략)
- 트랜잭션 입력 구성
- 트랜잭션 출력 구성
- 거스름돈 계산 및 출력 추가
- 서명 스크립트 생성
- 트랜잭션 수수료 계산
- 완성된 트랜잭션 서명

#### 5.3 지갑 기능
- 잔액 조회 (UTXO 합산)
- 트랜잭션 이력 조회
- 주소별 UTXO 목록
- 송금 기능
- 수신 주소 생성

#### 5.4 CLI 인터페이스
- clap을 사용한 명령줄 파싱
- 노드 제어 명령어
  - `start`: 노드 시작
  - `stop`: 노드 종료
  - `status`: 노드 상태
- 블록체인 조회 명령어
  - `getblock <hash>`: 블록 상세 정보
  - `getblockcount`: 현재 블록 높이
  - `gettx <txid>`: 트랜잭션 정보
  - `getbestblockhash`: 최신 블록 해시
- 지갑 명령어
  - `getnewaddress`: 새 주소 생성
  - `getbalance`: 잔액 조회
  - `listunspent`: UTXO 목록
  - `sendtoaddress <addr> <amount>`: 송금
  - `listtransactions`: 트랜잭션 이력
- 채굴 명령어
  - `mine`: 블록 채굴
  - `setmining <on|off>`: 자동 채굴 설정
- 네트워크 명령어
  - `getpeerinfo`: 연결된 피어 정보
  - `addnode <ip:port>`: 피어 수동 추가

#### 5.5 사용자 경험
- 명령어 도움말
- 에러 메시지 개선
- 진행 상황 표시
- 로깅 및 디버그 정보

### 완료 기준
- CLI로 모든 핵심 기능 조작 가능
- 새 주소 생성 및 잔액 조회 가능
- 다른 노드로 송금 가능
- 블록 채굴 가능
- 피어 연결 및 관리 가능
- 사용자 문서 작성 완료

### 예상 산출물
- 완전한 CLI 도구
- 지갑 모듈
- 트랜잭션 빌더
- 사용자 매뉴얼
- 예제 시나리오 (튜토리얼)

---

## 테스트 전략

### 단위 테스트
- 각 모듈별 독립적인 테스트
- 핵심 로직 커버리지 확보
- 엣지 케이스 테스트

### 통합 테스트
- 모듈 간 상호작용 테스트
- 블록 추가 시나리오
- 트랜잭션 생성 및 검증

### 네트워크 테스트
- 로컬 다중 노드 시뮬레이션
- 블록 전파 테스트
- 체인 동기화 테스트
- 네트워크 분할 및 복구

### 엔드투엔드 테스트
- 실제 사용 시나리오
  1. 노드 시작
  2. 제네시스 블록 로드
  3. 블록 채굴
  4. 다른 노드와 연결
  5. 트랜잭션 송금
  6. 블록 동기화 확인

---

## 문서화

### 코드 문서
- 모듈 및 함수 문서화 (rustdoc)
- 복잡한 알고리즘 주석
- 공개 API 문서

### 사용자 문서
- README: 프로젝트 소개 및 빌드 방법
- USAGE: CLI 명령어 가이드
- TUTORIAL: 단계별 사용 예제
- FAQ: 자주 묻는 질문

### 개발자 문서
- ARCHITECTURE: 시스템 설계
- CONTRIBUTING: 기여 가이드
- PROTOCOL: 네트워크 프로토콜 명세
- DESIGN_DECISIONS: 설계 결정 기록

---

## 마일스톤 요약

| Phase | 목표 | 핵심 산출물 |
|-------|------|-------------|
| 1 | 기초 구조 | 블록/트랜잭션 타입, 제네시스 블록 |
| 2 | 검증 로직 | PoW, P2PKH, 트랜잭션 검증 |
| 3 | 저장소 | 블록체인 DB, UTXO set |
| 4 | 네트워크 | P2P 프로토콜, 블록 전파 |
| 5 | 사용자 인터페이스 | 지갑, CLI |

각 단계는 독립적으로 완료하고 테스트한 후 다음 단계로 진행합니다.
